Class CameraChangeHandler : CustomFloatCVar
{
  override double ModifyValue(Name CVarName, double val)
  {
    return clamp(val, 1.0, 89.0);
  }
}

class PickupFlagHandler : CustomBoolCVar
{
  override bool ModifyValue(Name CVarName, bool val)
  {
	  if (gamestate == GS_LEVEL) players[consoleplayer].mo.bPickup = val;
	  return val;
  }
}

class SkyToggleHandler : CustomBoolCVar
{
  override bool ModifyValue(Name CVarName, bool val)
  {
	  if (gamestate == GS_LEVEL && !multiplayer)
	  {
		  if (val)
			  Level.ReplaceTextures(Texman.GetName(skyflatnum), "SKY1", TexMan.NOT_FLOOR); // Don't render sky from ceiling
		  else
			  Level.ReplaceTextures("SKY1", Texman.GetName(skyflatnum), TexMan.NOT_FLOOR);
	  }
	  return val;
  }
}

class selstruct
{
	array<Actor> selectables;
	array<Line> switches;
	int selnum, selobjsize, selswsize;
	bool isosel, inobjarray, inswarray, cursec_usable;
	Vector3 selpos;
	double viewh;
	Actor pmo;

	selstruct Init()
	{
		selectables.Clear(); selobjsize = 0;
		switches.Clear(); selswsize = 0;
		selnum = 0;
		isosel = false;
		inobjarray = true;
		inswarray = false;
		cursec_usable = false;
		selpos = (0., 0., 0.);
		return self;
	}
}

class MKeyEvents : EventHandler 
{
  cvar isodists[MAXPLAYERS], isopitches[MAXPLAYERS], isoyaws[MAXPLAYERS];
  cvar isoaims[MAXPLAYERS], rotlefts[MAXPLAYERS], rotrights[MAXPLAYERS];
  cvar lookingup[MAXPLAYERS], lookingdown[MAXPLAYERS], mousemove[MAXPLAYERS];
  selstruct psels[MAXPLAYERS];
  Vector3 delta;
  double target_angle, target_pitch;
  FLineTraceData t;

  override void OnRegister()
  {
	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
		  psels[i] = new("selstruct").Init();
		  isodists[i] = CVar.GetCVar("IsometricDist", players[i]);
		  isopitches[i] = CVar.GetCVar("IsometricPitch", players[i]);
		  isoyaws[i] = CVar.GetCVar("IsometricYaw", players[i]);
		  isoaims[i] = CVar.GetCVar("IsoAimAssist", players[i]);
		  rotlefts[i] = CVar.GetCVar("RotatingLeft", players[i]);
		  rotrights[i] = CVar.GetCVar("RotatingRight", players[i]);
		  lookingup[i] = CVar.GetCVar("IsoLookingUp", players[i]);
		  lookingdown[i] = CVar.GetCVar("IsoLookingDown", players[i]);
		  mousemove[i] = CVar.GetCVar("IsoMouseMove", players[i]);
	  }
  }
  
  //get angle and delta from two positions
  static vector3, double, double lookAt(Vector3 pos1, Vector3 pos2)
  {
	  //calculate difference between pos1 and pos2 (level.Vec3Diff takes portals into account)
	  Vector3 delta=level.Vec3Diff(pos1, pos2);
		
	  //calculate angle and pitch to other actor
	  double target_angle = atan2(delta.y, delta.x);
	  double target_pitch = -asin(delta.z/delta.length());

	  return delta, target_angle, target_pitch;
  }

  //get shorted xy-distance between actor and line
  static double shortest_dxy(Actor mo, Line ln)
  {
	  double lnlength = (ln.v1.p - ln.v2.p).length();
	  if (lnlength == 0.0) return (mo.pos.xy - ln.v1.p).length();
	  else
	  {
		  return abs((ln.v2.p.y - ln.v1.p.y)* mo.pos.x - (ln.v2.p.x - ln.v1.p.x)* mo.pos.y
					 + ln.v2.p.x * ln.v1.p.y - ln.v2.p.y * ln.v1.p.x) / lnlength;
	  }
  }

  override bool InputProcess (InputEvent e)
  {
	  if (e.Type == InputEvent.Type_KeyDown || e.Type == InputEvent.Type_KeyUp)
	  {
		  Inventory isomover = players[consoleplayer].mo.FindInventory("IsometricMovement");
		  if (mousemove[consoleplayer].GetBool() && isomover
			  && ((!IsometricMovement(isomover).pointmonster && !IsometricMovement(isomover).pointshootable)
				  || IsometricMovement(isomover).nolos2shootable				  
				  || IsometricMovement(isomover).pointusable || IsometricMovement(isomover).hipfire))
		  {
			  array<int> keys;
			  Bindings.GetAllKeysForCommand(keys, "+attack");
			  foreach (key : keys)
			  {
				  if (key && key == e.KeyScan)
				  {
					  SendNetworkEvent((e.Type == InputEvent.Type_KeyDown)
									   && !(players[consoleplayer].cmd.buttons & BT_FORWARD) // Avoid both keyboard and mouse moving forward
									   ? "FIREDOWN" : "FIREUP");
					  return ((e.Type == InputEvent.Type_KeyDown) || IsometricMovement(isomover).fleemode)
						  && !IsometricMovement(isomover).hipfire;
				  }
			  }
			  keys.Clear();
			  Bindings.GetAllKeysForCommand(keys, "+altattack");
			  foreach (key : keys)
			  {
				  if (key && key == e.KeyScan)
				  {
					  SendNetworkEvent(e.Type == InputEvent.Type_KeyDown ? "ALTFIREDOWN" : "ALTFIREUP");
					  return ((e.Type == InputEvent.Type_KeyDown) || IsometricMovement(isomover).fleemode)
						  && !IsometricMovement(isomover).hipfire;
				  }
			  }
			  keys.Clear();
			  Bindings.GetAllKeysForCommand(keys, "+forward");
			  foreach (key : keys)
			  {
				  if (key && key == e.KeyScan) // Don't move forward if there is a chance mouse is already moving forward
				  {
					  return (e.Type == InputEvent.Type_KeyDown) && (IsometricMovement(isomover).firekeydown);
				  }
			  }
			  keys.Clear();
			  Bindings.GetAllKeysForCommand(keys, "hip_fire_mode");
			  foreach (key : keys)
			  {
				  if (key && key == e.KeyScan)
				  {
					  SendNetworkEvent(e.Type == InputEvent.Type_KeyDown ? "HIPDOWN" : "HIPUP");
					  return false;
				  }
			  }
			  keys.Clear();
			  Bindings.GetAllKeysForCommand(keys, "flee_mode");
			  foreach (key : keys)
			  {
				  if (key && key == e.KeyScan)
				  {
					  SendNetworkEvent(e.Type == InputEvent.Type_KeyDown ? "FLEEDOWN" : "FLEEUP");
					  return false;
				  }
			  }
			  keys.Clear();
			  Bindings.GetAllKeysForCommand(keys, "mouse_rotate");
			  foreach (key : keys)
			  {
				  if (key && key == e.KeyScan)
				  {
					  SendNetworkEvent(e.Type == InputEvent.Type_KeyDown ? "MROTDOWN" : "MROTUP");
					  return false;
				  }
			  }
		  }
	  }

	  if (e.Type == InputEvent.Type_KeyDown)
		  SendNetworkEvent("MYKEYDOWN", e.KeyScan);

	  if (e.Type == InputEvent.Type_KeyUp)
		  SendNetworkEvent("MYKEYUP", e.KeyScan);
    
	  return false;
  }

  override void NetworkProcess(ConsoleEvent e)
  {

	  if ((e.Name == "FIREDOWN") || (e.Name == "FIREUP") || (e.Name == "ALTFIREDOWN") || (e.Name == "ALTFIREUP")
		  || (e.Name == "HIPDOWN") || (e.Name == "HIPUP") || (e.Name == "FLEEDOWN") || (e.Name == "FLEEUP")
		  || (e.Name == "MROTDOWN") || (e.Name == "MROTUP"))
	  {
		  Inventory isomover = players[e.Player].mo.FindInventory("IsometricMovement");
		  if (isomover)
		  {
			  if ((e.Name == "FIREDOWN") || (e.Name == "FIREUP"))
				  IsometricMovement(isomover).firekeydown = (e.Name == "FIREDOWN");
			  else if ((e.Name == "ALTFIREDOWN") || (e.Name == "ALTFIREUP"))
				  IsometricMovement(isomover).altfirekeydown = (e.Name == "ALTFIREDOWN");
			  else if ((e.Name == "HIPDOWN") || (e.Name == "HIPUP"))
				  IsometricMovement(isomover).hipfire = (e.Name == "HIPDOWN");
			  else if ((e.Name == "FLEEDOWN") || (e.Name == "FLEEUP"))
				  IsometricMovement(isomover).fleemode = (e.Name == "FLEEDOWN");
			  else if ((e.Name == "MROTDOWN") || (e.Name == "MROTUP"))
			  {
				  IsometricMovement(isomover).mrotate = (e.Name == "MROTDOWN");
				  if (e.Name == "MROTUP")
				  {
					  rotlefts[e.Player].SetBool(false);
					  rotrights[e.Player].SetBool(false);
				  }
			  }
		  }
	  }
	  
    if (e.Name == "MYKEYDOWN")
    {
		if (!psels[e.Player].pmo) psels[e.Player].pmo = players[e.Player].mo;
		array<int> keys;
		Bindings.GetAllKeysForCommand(keys, "rotate_cam_left");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
				rotlefts[e.Player].SetBool(true);
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "rotate_cam_right");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
				rotrights[e.Player].SetBool(true);
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "iso_zoom_in");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				if (!automapactive && (gamestate == GS_LEVEL) && players[e.Player].camera && players[e.Player].camera.GetClassName() == 'SpectatorCamera')
				{
					isodists[e.Player].SetFloat(clamp(isodists[e.Player].GetFloat() - 10.0, 0.0, 1000.0));
					SpectatorCamera(players[e.Player].camera).Init(isodists[e.Player].GetFloat(),
																   isoyaws[e.Player].GetFloat(),
																   isopitches[e.Player].GetFloat(), -1);
				}
			}
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "iso_zoom_out");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				if (!automapactive && (gamestate == GS_LEVEL) && players[e.Player].camera && players[e.Player].camera.GetClassName() == 'SpectatorCamera')
				{
					isodists[e.Player].SetFloat(clamp(isodists[e.Player].GetFloat() + 10.0, 0.0, 1000.0));
					SpectatorCamera(players[e.Player].camera).Init(isodists[e.Player].GetFloat(),
																   isoyaws[e.Player].GetFloat(),
																   isopitches[e.Player].GetFloat(), -1);
				}
			}
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "iso_aim_assist");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				isoaims[e.Player].SetBool(!isoaims[e.Player].GetBool());
				if (e.Player == consoleplayer)
				{
					if (isoaims[e.Player].GetBool()) console.printf("Aim Assist Enabled");
					else console.printf("Aim Assist Disabled");
				}
			}
		}

		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "clear_select");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				psels[e.Player].isosel = false;
			}
		}

		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "look_up");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				lookingup[e.Player].SetBool(true);
			}
		}

		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "look_down");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				lookingdown[e.Player].SetBool(true);
			}
		}

		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "use_selected");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				let psel = psels[e.Player];
				if (psel.isosel)
				{
					if (psel.inswarray && (psel.switches.Size() > psel.selnum) && psel.switches[psel.selnum])
					{
						Vector3 midln = ((psel.switches[psel.selnum].v1.p.x + psel.switches[psel.selnum].v2.p.x)*0.5,
										 (psel.switches[psel.selnum].v1.p.y + psel.switches[psel.selnum].v2.p.y)*0.5,
										 psel.pmo.pos.Z + psel.viewh);
						[delta, target_angle, target_pitch] = lookAt(psel.pmo.pos + (0, 0, psel.viewh), midln);
						bool tbool = psel.pmo.LineTrace(target_angle,
														(psel.pmo.pos.xy - midln.xy).length() + 8.0,
														0, TRF_THRUACTORS | TRF_BLOCKUSE, psel.viewh, data:t);
						bool swvisible = true;
						if (!tbool || (t.hitType != TRACE_HitWall) || !t.hitLine || (t.hitLine.Index() != psel.switches[psel.selnum].Index()))
						{
							// Center of wall not in line of sight of the player
							swvisible = !tbool;
							if (!tbool)
							{
								// Maybe the line isn't a wall! Check if it can for SPAC_UseBack condition
								int plside = Level.ActorOnLineSide(psel.pmo, psel.switches[psel.selnum]);
								if (plside == 1 && !(psel.switches[psel.selnum].activation & SPAC_UseBack)) { swvisible = false; }
								if (plside == 0 && ((psel.switches[psel.selnum].activation & (SPAC_Use | SPAC_UseThrough | SPAC_UseBack)) == SPAC_UseBack))
								{
									swvisible = false;
								}
							}
						}
						if (swvisible)
						{
							if (psel.switches[psel.selnum].activation & (SPAC_Use | SPAC_UseThrough | SPAC_UseBack))
							{
								int side = 0; // Level.ActorOnLineSide(pmo, switches[selnum]); // SPAC_UseBack gives me segfaults
								if (!psel.switches[psel.selnum].Activate(psel.pmo, side, SPAC_Use)) // (side == 0 ? SPAC_Use : SPAC_UseBack)))
									psel.pmo.A_StartSound("noselect", CHAN_ITEM);
							}
						} else {
							psel.pmo.A_StartSound("noselect", CHAN_ITEM);
						}
					} else if (psel.inobjarray && (psel.selectables.Size() > psel.selnum)
							   && psel.selectables[psel.selnum]) {
						[delta, target_angle, target_pitch] = lookAt(psel.pmo.pos + (0, 0, psel.viewh),
																	 psel.selectables[psel.selnum].pos
																	 + (0, 0, psel.selectables[psel.selnum].height*0.5));
						bool tbool = psel.pmo.LineTrace(target_angle, players[e.Player].mo.UseRange, target_pitch,
														TRF_ALLACTORS | TRF_BLOCKUSE, psel.viewh, data:t);
						if (!tbool || (t.hitType != TRACE_HitActor) || !t.hitActor || (t.hitActor != psel.selectables[psel.selnum]))
						{
							psel.pmo.A_StartSound("noselect", CHAN_ITEM);
						} else {
							if (psel.selectables[psel.selnum].bSPECIAL)
							{
								psel.selectables[psel.selnum].Touch(psel.pmo);
							} else if (psel.selectables[psel.selnum].bUSESPECIAL && psel.selectables[psel.selnum].health > 0) {
								// This whole segment is only for old DECORATE type activate functions
								let thing = psel.selectables[psel.selnum];
								if (thing.activationtype & (THINGSPEC_Activate | THINGSPEC_Deactivate | THINGSPEC_Switch))
								{
									if ((thing.activationtype & THINGSPEC_Switch)
										&& !(thing.activationtype & (THINGSPEC_Activate | THINGSPEC_Deactivate)))
									{
										thing.activationtype |= THINGSPEC_Activate;
									}
									// Can it be activated?
									if (thing.activationtype & THINGSPEC_Activate)
									{
										thing.activationtype &= ~THINGSPEC_Activate; // Clear flag
										if (thing.activationtype & THINGSPEC_Switch) // Set other flag if switching
											thing.activationtype |= THINGSPEC_Deactivate;
										thing.Activate(psel.pmo);
									}
									// If not, can it be deactivated?
									else if (thing.activationtype & THINGSPEC_Deactivate)
									{
										thing.activationtype &= ~THINGSPEC_Deactivate; // Clear flag
										if (thing.activationtype & THINGSPEC_Switch)	// Set other flag if switching
											thing.activationtype |= THINGSPEC_Activate;
										thing.Deactivate(psel.pmo);
									}
								}
							} else if (!psel.selectables[psel.selnum].Used(psel.pmo)) {
								psel.pmo.A_StartSound("noselect", CHAN_ITEM);
							}
						}
					} else if (psel.cursec_usable && !psel.inswarray && !psel.inobjarray) {
						if (!psel.pmo.CurSector.SecActTarget || !psel.pmo.CurSector.TriggerSectorActions(psel.pmo, SectorAction.SECSPAC_Use))
							psel.pmo.A_StartSound("noselect", CHAN_ITEM);
					}
					psel.isosel = false;
				}
			}
		}

		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "cycle_select");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
			{
				let psel = psels[e.Player];
				psel.viewh = players[e.Player].mo.viewheight*players[e.Player].crouchfactor; // players[e.Player].mo.height*0.5;
				if (psel.isosel)
				{
					// Handle next selection change, if possible
					if (psel.inswarray && (psel.switches.Size() > 0))
					{
						if (++psel.selnum >= psel.switches.Size())
						{
							psel.selnum = 0;
							if (!psel.cursec_usable && (psel.selectables.Size() > 0)) { psel.inobjarray = true; psel.inswarray = false; }
							else if (psel.cursec_usable) { psel.inswarray = false; }
						}
					} else if (psel.inobjarray && (psel.selectables.Size() > 0)) {
						if (++psel.selnum >= psel.selectables.Size())
						{
							psel.selnum = 0;
							if (!psel.cursec_usable && (psel.switches.Size() > 0)) { psel.inobjarray = false; psel.inswarray = true; }
							else if (psel.cursec_usable) { psel.inobjarray = false; }
						}
					} else if (psel.cursec_usable && !psel.inswarray && !psel.inobjarray) {
						psel.selnum = 0;
						if (psel.switches.Size() > 0) psel.inswarray = true;
						else if (psel.selectables.Size() > 0) psel.inobjarray = true;
					}

					// Update selected marker position
					if (psel.cursec_usable && !psel.inswarray && !psel.inobjarray)
					{
						psel.selpos = (psel.pmo.pos.X, psel.pmo.pos.Y, psel.pmo.floorz);
					} else if (psel.inswarray && (psel.switches.Size() > psel.selnum)) {
						Vector3 midln = ((psel.switches[psel.selnum].v1.p.x + psel.switches[psel.selnum].v2.p.x)*0.5,
										 (psel.switches[psel.selnum].v1.p.y + psel.switches[psel.selnum].v2.p.y)*0.5,
										 psel.pmo.pos.Z + psel.viewh);
						[delta, target_angle, target_pitch] = lookAt(psel.pmo.pos + (0, 0, psel.viewh), midln);
						bool tbool = psel.pmo.LineTrace(target_angle,
														(psel.pmo.pos.xy - midln.xy).length() + 8.0,
														0, TRF_THRUACTORS | TRF_BLOCKUSE, psel.viewh, data:t);
						if (!tbool || (t.hitType != TRACE_HitWall) || !t.hitLine || (t.hitLine.Index() != psel.switches[psel.selnum].Index()))
						{
							// Center of wall not in line of sight of the player
							bool setfalse = tbool;
							if (!tbool)
							{
								// Maybe the line isn't a wall! Check if it can for SPAC_UseBack condition
								int plside = Level.ActorOnLineSide(psel.pmo, psel.switches[psel.selnum]);
								if (plside == 1 && !(psel.switches[psel.selnum].activation & SPAC_UseBack)) { setfalse = true; }
								if (plside == 0 && ((psel.switches[psel.selnum].activation & (SPAC_Use | SPAC_UseThrough | SPAC_UseBack)) == SPAC_UseBack))
								{
									setfalse = true;
								}
							}
							if (setfalse)
							{
								// Something is obstucting it from the player
								psel.pmo.A_StartSound("noselect", CHAN_ITEM);
								psel.isosel = false;;
							}
						}
						if (psel.isosel) {
							psel.selpos = ((psel.switches[psel.selnum].v1.p.x + psel.switches[psel.selnum].v2.p.x)*0.5,
										   (psel.switches[psel.selnum].v1.p.y + psel.switches[psel.selnum].v2.p.y)*0.5,
										   psel.pmo.pos.Z + psel.viewh);
						}
					} else if (psel.inobjarray && (psel.selectables.Size() > psel.selnum)) {
						[delta, target_angle, target_pitch] = lookAt(psel.pmo.pos + (0, 0, psel.viewh),
																	 psel.selectables[psel.selnum].pos
																	 + (0, 0, psel.selectables[psel.selnum].height*0.5));
						bool tbool = psel.pmo.LineTrace(target_angle, players[e.Player].mo.UseRange, target_pitch,
														TRF_ALLACTORS | TRF_BLOCKUSE, psel.viewh, data:t);
						if (!tbool || (t.hitType != TRACE_HitActor) || !t.hitActor || (t.hitActor != psel.selectables[psel.selnum]))
						{
							psel.pmo.A_StartSound("noselect", CHAN_ITEM);
							psel.isosel = false;
						} else {
							psel.selpos = psel.selectables[psel.selnum].Pos + (0., 0., psel.selectables[psel.selnum].height*0.5);
							console.printf("%s selected\n", psel.selectables[psel.selnum].GetClassName());
						}
					}

					if (!(psel.inobjarray || psel.inswarray || psel.cursec_usable))//(selectables.Size() == 0) && (switches.Size() == 0))
					{
						psel.pmo.A_StartSound("noselect", CHAN_ITEM);
						psel.isosel = false;
					}
				} else {
					psel.Init();
					psel.cursec_usable = (psel.pmo.CurSector.SecActTarget != null);
					BlockThingsIterator it = BlockThingsIterator.Create(psel.pmo, players[e.Player].mo.UseRange);
					Actor obj;
					while (it.Next())
					{
						obj = it.Thing;
						if (!obj || obj.player || obj.bISMONSTER || obj.bCORPSE || obj.bMASTERNOSEE || obj.bONLYVISIBLEINMIRRORS || obj.bDORMANT || obj.bINVISIBLE || obj.bMISSILE || obj.bNOINTERACTION || obj.bICECORPSE || obj.bCRASHED || obj.bINCONVERSATION || psel.pmo.Distance3D(obj) > players[e.Player].mo.UseRange)
							continue;
						[delta, target_angle, target_pitch] = lookAt(psel.pmo.pos + (0, 0, psel.viewh),
																	 obj.pos + (0, 0, obj.height*0.5));
						bool tbool = psel.pmo.LineTrace(target_angle, players[e.Player].mo.UseRange, target_pitch,
														TRF_ALLACTORS | TRF_BLOCKUSE, psel.viewh, data:t);
						if (!tbool || (t.hitType != TRACE_HitActor) || !t.HitActor || (t.HitActor != obj))
							continue;
						psel.selectables.Push(obj);
						psel.selobjsize++;
						// console.printf("Added %s\n", obj.GetClassName());
					}
					BlockLinesIterator it2 = BlockLinesIterator.Create(psel.pmo, players[e.Player].mo.UseRange);
					Line ln;
					while (it2.Next())
					{
						ln = it2.CurLine;

						if (shortest_dxy(psel.pmo, ln) > players[e.Player].mo.UseRange)
							continue;

						if (((psel.pmo.pos.xy - ln.v1.p) dot (ln.v2.p - ln.v1.p) < 0)
							|| ((psel.pmo.pos.xy - ln.v2.p) dot (ln.v1.p - ln.v2.p) < 0))
						{
							if ((psel.pmo.pos.xy - ln.v1.p).length() > players[e.Player].mo.UseRange
								&& (psel.pmo.pos.xy - ln.v2.p).length() > players[e.Player].mo.UseRange) continue;
						}

						if (!(ln.activation & (SPAC_Use | SPAC_UseThrough | SPAC_UseBack)) || (ln.special == 0))
						{
							int pside = Level.ActorOnLineSide(psel.pmo, ln);
							Sector sec = pside == 0 ? ln.frontsector : ln.backsector;
							if (((sec != null) && (sec.SecActTarget == null)))
								continue;
						}
						if (ln.special == 0) continue;
						psel.switches.Push(ln);
						psel.selswsize++;
					}
					for (int iter = 0; iter < psel.switches.Size(); iter++)
					{
						// Something in LineTrace() prevents this from being called inside the BlockLinesIterator while loop
						ln = psel.switches[iter];
						Vector3 midln = ((ln.v1.p.x + ln.v2.p.x)*0.5,
										 (ln.v1.p.y + ln.v2.p.y)*0.5,
										 psel.pmo.pos.Z + psel.viewh);
						[delta, target_angle, target_pitch] = lookAt(psel.pmo.pos + (0, 0, psel.viewh), midln);
						bool tempbool = psel.pmo.LineTrace(target_angle,
														   (psel.pmo.pos.xy - midln.xy).length() + 8.0,
														   0, TRF_THRUACTORS | TRF_BLOCKUSE, psel.viewh, data:t);
						if (!tempbool || (t.HitType != TRACE_HitWall) || !t.HitLine || (t.HitLine.Index() != ln.Index()))
						{
							// Center of wall not in line of sight of the player
							if (!tempbool)
							{
								// Maybe the line isn't a wall! Check if it can for SPAC_UseBack condition
								int plside = Level.ActorOnLineSide(psel.pmo, ln);
								if (plside == 1 && !(ln.activation & SPAC_UseBack)) { psel.switches.Delete(iter--); }
								if (plside == 0 && ((ln.activation & (SPAC_Use | SPAC_UseThrough | SPAC_UseBack)) == SPAC_UseBack))
									{ psel.switches.Delete(iter--); }
							} else {
								// Something is obstucting it from the player
								psel.switches.Delete(iter--);
							}
						}
					}
					psel.selswsize = psel.switches.Size();
					psel.isosel = (psel.cursec_usable || (psel.selswsize > 0) || (psel.selobjsize > 0));
					if (psel.cursec_usable) {
						psel.selpos = (psel.pmo.pos.X, psel.pmo.pos.Y, psel.pmo.floorz);
					} else if (psel.selswsize > 0) {
						psel.inswarray = true;
						psel.selpos = ((psel.switches[0].v1.p.x + psel.switches[0].v2.p.x)*0.5,
									   (psel.switches[0].v1.p.y + psel.switches[0].v2.p.y)*0.5,
									   psel.pmo.pos.Z + psel.viewh);
						// console.printf("%d Lines selected\n", psel.selswsize);
					} else if (psel.selobjsize > 0) {
						psel.inobjarray = true;
						psel.selpos = psel.selectables[0].pos + (0., 0., psel.selectables[0].height*0.5);
						console.printf("%s selected\n", psel.selectables[0].GetClassName());
					} else {
						psel.pmo.A_StartSound("noselect", CHAN_ITEM);
					}
				}
			}
		}
	}
    else if (e.Name == "MYKEYUP")
    {
		int key1, key2;
		[key1, key2] = Bindings.GetKeysForCommand("rotate_cam_left");
		array<int> keys;
		Bindings.GetAllKeysForCommand(keys, "rotate_cam_left");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
				rotlefts[e.Player].SetBool(false);
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "rotate_cam_right");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
				rotrights[e.Player].SetBool(false);
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "look_up");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
				lookingup[e.Player].SetBool(false);
		}
		keys.clear();
		Bindings.GetAllKeysForCommand(keys, "look_down");
		foreach (key : keys)
		{
			if (key && key == e.Args[0])
				lookingdown[e.Player].SetBool(false);
		}
	}
  }

  override void WorldThingDestroyed(WorldEvent e) 
  {
	  if (e.Thing)
	  {
		  for (int i = 0; i < MAXPLAYERS; i++)
		  {
			  if (PlayerInGame[i] && players[i].mo && (psels[i].selobjsize > 0))
			  {
				  int thindex = psels[i].selectables.Find(e.Thing);
				  if (thindex != psels[i].selobjsize) // selectables.Size()
				  {
					  psels[i].selectables.Delete(thindex);
					  psels[i].selobjsize--;
				  }
			  }
		  }
	  }
  }

  override void WorldTick()
  {
	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
		  if (PlayerInGame[i] && players[i].mo && psels[i].isosel)
		  {
			  if ((players[i].mo.Vel.X != 0) || (players[i].mo.Vel.Y != 0))
			  {
				  psels[i].isosel = false;
			  }
		  }
	  }
  }
}

class StartingInventoryHandler : EventHandler
{
	override void PlayerEntered(PlayerEvent e)
	{
		players[e.PlayerNumber].mo.A_GiveInventory("Z_NashMove", 1);
		players[e.PlayerNumber].mo.A_GiveInventory("MoveTorch", 1);
		players[e.PlayerNumber].mo.A_GiveInventory("IsometricMovement", 1);
	}
}

//Camera actor for player's scope
class ScopeCamera : SpectatorCamera
{
	playerpawn ppawn;
	cvar FirstPerson;

	override void postbeginplay()
	{
	  super.postbeginplay();
	  ppawn=playerpawn(target);
	  if(ppawn) FirstPerson = Cvar.GetCvar("IsoHUDScopeFirstPerson", ppawn.player);
	}

	override void tick()
	{
	  if(!ppawn)
	  {
	    destroy();
	    return;
	  }

	  if (FirstPerson.GetBool())
	  {
		  A_SetAngle(ppawn.angle, SPF_INTERPOLATE);
		  A_SetPitch(ppawn.pitch, SPF_INTERPOLATE);
		  A_SetRoll(ppawn.roll);

		  SetOrigin(ppawn.pos + (ppawn.radius * Cos(ppawn.angle),
								 ppawn.radius * Sin(ppawn.angle),
								 0.25 * ppawn.height), true);
	  } else {
		  Super.Tick();
	  }
	}
}

class LoadGameCameraHandler : StaticEventHandler
{
	int camflags;
	override void OnRegister()
	{
		camflags = VPSF_ABSOLUTEOFFSET | VPSF_ORTHOGRAPHIC | VPSF_ALLOWOUTOFBOUNDS;
	}

	override void WorldLoaded (WorldEvent e) 
	{
		if(e.IsSaveGame)
		{
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (PlayerInGame[i] && players[i].mo)
				{
					CVar isodist = CVar.GetCVar("IsometricDist", players[i]);
					CVar isoyaw = CVar.GetCVar("IsometricYaw", players[i]);
					CVar isopitch = CVar.GetCVar("IsometricPitch", players[i]);
					Actor myisocam = CameraSpawnHandler(EventHandler.Find("CameraSpawnHandler")).isocam[i];
					if (myisocam)
					{
						players[i].camera = myisocam;
						SpectatorCamera(players[i].camera).Init(isodist.GetFloat(), isoyaw.GetFloat(), isopitch.GetFloat(), camflags);
					}
					Actor myscopecam = CameraSpawnHandler(EventHandler.Find("CameraSpawnHandler")).scopecam[i];
					if (myscopecam)
					{
						if (!Cvar.GetCvar("IsoHUDScopeFirstPerson", players[i]).GetBool())
							SpectatorCamera(myscopecam).Init(isodist.GetFloat(), isoyaw.GetFloat(), isopitch.GetFloat(), camflags);
					}
				}
			}
		}
	}
}

class CameraSpawnHandler : EventHandler // Can't be static because camera actor gets spawned
{
	cvar isodists[MAXPLAYERS], isoyaws[MAXPLAYERS], isopitches[MAXPLAYERS];
	cvar isospeeds[MAXPLAYERS], rotatelefts[MAXPLAYERS], rotaterights[MAXPLAYERS];
	Actor isocam[MAXPLAYERS], scopecam[MAXPLAYERS];
	int replaceceilingskytimer;

	override void OnRegister()
	{
		replaceceilingskytimer = 0;
	}

	override void PlayerSpawned(playerEvent e)
	{
		if (gamestate != GS_TITLELEVEL)
		{
			// Add a scope camera to each player, and store it in scopecam
			if (scopecam[e.PlayerNumber] == NULL)
				scopecam[e.PlayerNumber] = Actor.Spawn("ScopeCamera", players[e.PlayerNumber].mo.pos, ALLOW_REPLACE);
			scopecam[e.PlayerNumber].target = players[e.PlayerNumber].mo;
			// When the player spawns, spawn an isometric spectator camera:
			players[e.PlayerNumber].mo.ViewBob = 0;
			players[e.PlayerNumber].mo.FlyBob = 0;
			if (isocam[e.PlayerNumber] == NULL)
				isocam[e.PlayerNumber] = SpectatorCamera(Actor.Spawn("SpectatorCamera", players[e.PlayerNumber].mo.pos));
			players[e.PlayerNumber].camera = isocam[e.PlayerNumber];
			players[e.PlayerNumber].camera.tracer = players[e.PlayerNumber].mo; // This makes camera follow the player
			players[e.PlayerNumber].camera.player = players[e.PlayerNumber]; // Necessary for pain and pickup screen flashes. Adds viewbob too.
			int camflags = LoadGameCameraHandler(StaticEventHandler.Find("LoadGameCameraHandler")).camflags;
			CVar isodist = CVar.GetCVar("IsometricDist", players[e.PlayerNumber]);
			CVar isoyaw = CVar.GetCVar("IsometricYaw", players[e.PlayerNumber]);
			CVar isopitch = CVar.GetCVar("IsometricPitch", players[e.PlayerNumber]);
			SpectatorCamera(players[e.PlayerNumber].camera).Init(isodist.GetFloat(), isoyaw.GetFloat(), isopitch.GetFloat(), camflags);
			if (!Cvar.GetCvar("IsoHUDScopeFirstPerson", players[e.PlayerNumber]).GetBool())
				SpectatorCamera(scopecam[e.PlayerNumber]).Init(isodist.GetFloat(), isoyaw.GetFloat(), isopitch.GetFloat(), camflags);
			// The following has to come after Init
			// SpectatorCamera(players[e.PlayerNumber].camera).lagdistance = 300.0; // Use for a lazy camera that only follows if you get away from center
			// SpectatorCamera(players[e.PlayerNumber].camera).chasemode = 2; // 0: chase until tracer centered, 1: same but only when tracer is moving, 2: stop chase if tracer within lagdistance
			if (CVar.FindCVar("IsoShowOpeningMsg").GetBool())
			{
				CVar.FindCVar("IsoShowOpeningMsg").SetBool(false);
				if (players[e.PlayerNumber].camera)
				{
					players[e.PlayerNumber].camera.A_Print("Don't forget to bind keys to\nROTATE and ZOOM the CAMERA.\n\nToggle 'visibility through level geometry'\nin the options menu.", 10, "BIGUPPER");
				}
			}
		}
	}

	override void PlayerDisconnected (PlayerEvent e)
	{
		// This is needed if a player disconnects from a multiplayer session
		if(isocam[e.PlayerNumber]) isocam[e.PlayerNumber].Destroy();
	}

	override void WorldLoaded (WorldEvent e)
	{
		if (CVar.FindCVar("IsoDisableCeilingSky").GetBool() || multiplayer)
			replaceceilingskytimer = 1;
		if (gamestate != GS_TITLELEVEL)
		{
			ThinkerIterator MonsterFinder = ThinkerIterator.Create("Actor");
			Actor mo;
			while ((mo = Actor(MonsterFinder.Next())))
			{
				if (mo.bIsMonster && mo.MaxTargetRange > IsoMonsterAimMaxDist) mo.MaxTargetRange = IsoMonsterAimMaxDist;
			}
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (PlayerInGame[i] && players[i].mo)
				{
					// Add a scope camera to each player, and store it in scopecam
					if (scopecam[i] == NULL)
						scopecam[i] = Actor.Spawn("ScopeCamera", players[i].mo.pos, ALLOW_REPLACE);
					scopecam[i].target = players[i].mo;
					// When World loads, spawn an isometric spectator camera:
					players[i].mo.ViewBob = 0;
					players[i].mo.FlyBob = 0;
					if (isocam[i] == NULL)
						isocam[i] = SpectatorCamera(Actor.Spawn("SpectatorCamera", players[i].mo.pos));
					players[i].camera = isocam[i];
					players[i].camera.tracer = players[i].mo; // This makes camera follow the player
					players[i].camera.player = players[i]; // Necessary for pain and pickup screen flashes. Adds viewbob too.
					int camflags = LoadGameCameraHandler(StaticEventHandler.Find("LoadGameCameraHandler")).camflags;
					isodists[i] = CVar.GetCVar("IsometricDist", players[i]);
					isoyaws[i] = CVar.GetCVar("IsometricYaw", players[i]);
					isopitches[i] = CVar.GetCVar("IsometricPitch", players[i]);
					isospeeds[i] = CVar.GetCVar("IsometricSpeed", players[i]);
					rotatelefts[i] = CVar.GetCVar("RotatingLeft", players[i]);
					rotaterights[i] = CVar.GetCVar("RotatingRight", players[i]);
					SpectatorCamera(players[i].camera).Init(isodists[i].GetFloat(), isoyaws[i].GetFloat(), isopitches[i].GetFloat(), camflags);
					if (!Cvar.GetCvar("IsoHUDScopeFirstPerson", players[i]).GetBool())
						SpectatorCamera(scopecam[i]).Init(isodists[i].GetFloat(), isoyaws[i].GetFloat(), isopitches[i].GetFloat(), camflags);
					// The following has to come after Init
					// SpectatorCamera(players[i].camera).lagdistance = 300.0; // Use for a lazy camera that only follows if you get away from center
					// SpectatorCamera(players[i].camera).chasemode = 2; // 0: chase until tracer centered, 1: same but only when tracer is moving, 2: stop chase if tracer within lagdistance
				}
			}
		}
	}

  // destroy the camera when this level is unloaded
  // in the case of hub levels, we don't want to spawn extra cameras
  // when the player returns to this level
  override void WorldUnloaded(WorldEvent e)
  {
	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
		  if (PlayerInGame[i] && players[i].mo)
		  {
			  if (scopecam[i])
			  {
				  scopecam[i].Destroy();
			  }
			  if (isocam[i])
			  {
				  isocam[i].Destroy();
				  players[i].mo.A_SetBlend("00 00 00", 1.0, 35); // Blank screen so first-person view isn't momentarily seen
			  }
		  }
	  }
  }

  override void WorldTick()
  {
	  if (gamestate != GS_LEVEL) return;

	  if (replaceceilingskytimer > 0)
	  {
		  replaceceilingskytimer++;
		  if (replaceceilingskytimer > TICRATE) // Some maps seem to need this delay
		  {
			  Level.ReplaceTextures(Texman.GetName(skyflatnum), "SKY1", TexMan.NOT_FLOOR); // Don't render sky from ceiling
			  replaceceilingskytimer = 0;
		  }
	  }

	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
		  if (PlayerInGame[i] && players[i].mo)
		  {
			  if ((!players[i].camera || (players[i].camera == players[i].mo)) && isocam[i])
			  {
				  // player.camera was reset for some reason
				  // Retreive from storage
				  players[i].camera = isocam[i];
			  }
			  if (players[i].camera)
			  {
				  if (rotatelefts[i].GetBool() || rotaterights[i].GetBool())
				  {
					  isoyaws[i].SetFloat(isoyaws[i].GetFloat() + (rotaterights[i].GetBool() ? 1 : -1) * isospeeds[i].GetFloat());
					  int camflags = LoadGameCameraHandler(StaticEventHandler.Find("LoadGameCameraHandler")).camflags;
					  if (players[i].camera.GetClassName() == 'SpectatorCamera')
					  {
						  SpectatorCamera(players[i].camera).Init(isodists[i].GetFloat(),
																  isoyaws[i].GetFloat(),
																  isopitches[i].GetFloat(), camflags);
						  if (!Cvar.GetCvar("IsoHUDScopeFirstPerson", players[i]).GetBool())
						  {
							  SpectatorCamera(scopecam[i]).Init(isodists[i].GetFloat(),
																isoyaws[i].GetFloat(),
																isopitches[i].GetFloat(), camflags);
						  }
					  }
				  }
			  }
		  }
	  }
  }
}

class RenderCursorsOverlay : EventHandler
{
	cvar isoyaw, isopitch, isoaimdist, isoaimassist;
	cvar showwep, showwepname, showscope, showscopehealth;
	cvar wepsize, wepxpos, wepypos;
	cvar scopesize, scopexpos, scopeypos;
	cvar aimbeam, scopetype, cursdist, cursoffy;
	cvar lookingup, lookingdown;
	cvar mousemove, firstpersonscope, scopetargetname;
	FLineTraceData t[MAXPLAYERS];
	Vector3 hitloc;
	Actor actorhit[MAXPLAYERS];
	ui int oldmx, oldmy;

	// getActorMaxHealth(), makeHpBar(), and makeRepeating() functions
	// are derived from similar functions defined in the Target-Spy mod
	// by Author m8f: https://github.com/mmaulwurff/target-spy
	// The Target-Spy mod as released under the GPLv3 license, and a
	// copy of said license is included in the root directory as
	// GPLv3.txt

	ui static int getActorMaxHealth(Actor a)
	{
	  if (a == NULL) { return 0; }

	  if (a.player && a.player.mo) { return a.player.mo.getMaxHealth(); }

	  int maxHealth = a.spawnHealth();

	  return maxHealth;
	}

	ui static string makeHpBar(int health, int maxHealth, bool logScale = false)
	{	  
	  bool greenRedTheme = true;
	  int greenColor = 3;
	  int redColor = 6;
	  string pip = "|";
	  string emptyPip = "-";
	  double lengthMultiplier = 1.0;

	  int length;
	  if (logScale)               { length = int(Log(maxHealth)) * 2; }
	  else if (maxHealth >= 2000) { length = 30; }
	  else if (maxHealth >= 500)  { length = 20; }
	  else                        { length = 10; }

	  length = int(round(length * lengthMultiplier));

	  int nPips;
	  if (maxHealth < 1)
	  {
	    nPips = 0;
	  }
	  else
	  {
	    nPips = int(round(double(health) * length / maxHealth));
	    nPips = clamp(nPips, 0, length);
	  }

	  string pipColor;
	  string emptyColor;
	  if (greenRedTheme)
	  {
	    pipColor   = String.Format("\c%c", 97 + greenColor); // 'a'
	    emptyColor = String.Format("\c%c", 97 + redColor);   // 'a'
	  }
	  else
	  {
	    pipColor   = "";
	    emptyColor = "";
	  }

	  return String.Format( "%s%s%s%s"
				, pipColor
				, MakeRepeating(pip, nPips)
				, emptyColor
				, MakeRepeating(emptyPip, length - nPips)
				);

	}

	ui static string makeRepeating(string s, int n)
	{
	  if (n == 0) { return ""; }
	  string format = string.format("%%%ds", n);
	  string result = string.format(format, " ");
	  result.replace(" ", s);
	  return result;
	}
	
	override void OnRegister()
	{
	  isoyaw = CVar.GetCVar("IsometricYaw", players[consoleplayer]);
	  isopitch = CVar.GetCVar("IsometricPitch", players[consoleplayer]);
	  isoaimdist = CVar.GetCVar("IsoAimAssistMaxDist", players[consoleplayer]);
	  isoaimassist = CVar.GetCVar("IsoAimAssist", players[consoleplayer]);
	  mousemove = CVar.GetCVar("IsoMouseMove", players[consoleplayer]);
	  showwep = CVar.GetCVar("IsoHUDShowWeapon", players[consoleplayer]);
	  showwepname = CVar.GetCVar("IsoHUDShowWeaponName", players[consoleplayer]);
	  showscope = CVar.GetCVar("IsoHUDShowTarget", players[consoleplayer]);
	  showscopehealth = CVar.GetCVar("IsoHUDShowTargetHealth", players[consoleplayer]);
	  wepsize = CVar.GetCVar("IsoHUDWeaponSize", players[consoleplayer]);
	  wepxpos = CVar.GetCVar("IsoHUDWeaponXPos", players[consoleplayer]);
	  wepypos = CVar.GetCVar("IsoHUDWeaponYPos", players[consoleplayer]);
	  scopesize = CVar.GetCVar("IsoHUDTargetSize", players[consoleplayer]);
	  scopexpos = CVar.GetCVar("IsoHUDTargetXPos", players[consoleplayer]);
	  scopeypos = CVar.GetCVar("IsoHUDTargetYPos", players[consoleplayer]);
	  aimbeam  = CVar.GetCVar("IsoAimBeam", players[consoleplayer]);
	  scopetype = CVar.GetCVar("IsoHUDScopeType", players[consoleplayer]);
	  cursdist = CVar.GetCVar("IsoCursorDist", players[consoleplayer]);
	  cursoffy = CVar.GetCVar("IsoCursorOffsetY", players[consoleplayer]);
	  lookingup = CVar.GetCVar("IsoLookingUp", players[consoleplayer]);
	  lookingdown = CVar.GetCVar("IsoLookingDown", players[consoleplayer]);
	  firstpersonscope = CVar.GetCVar("IsoHUDScopeFirstPerson", players[consoleplayer]);
	  scopetargetname = CVar.GetCVar("IsoHUDShowTargetName", players[consoleplayer]);
	  hitloc = (0, 0, 0);
	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
	    actorhit[i] = NULL; // false;
	  }
	}

	override void WorldTick()
	{
	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
		if (PlayerInGame[i] && players[i].mo)
		{
			PlayerPawn pmo = players[i].mo;
			float max_dist = isoaimdist.GetFloat();
			if (pmo.LineTrace(pmo.angle, max_dist, pmo.pitch, TRF_NOSKY, pmo.viewheight*pmo.player.crouchfactor, data:t[i]))
			{
				if ((t[i].HitType == TRACE_HitActor) && t[i].hitActor.bISMONSTER && !t[i].hitActor.bFRIENDLY && !t[i].hitActor.bCORPSE)
					actorhit[i] = t[i].HitActor; // true;
				else
					actorhit[i] = NULL; // false;
			}
			else
				actorhit[i] = NULL; // false;
		}
	  }
	}
	
	override void RenderUnderlay(RenderEvent e)
	{
		if (!automapactive && (gamestate == GS_LEVEL) && players[consoleplayer].camera.GetClassName() == 'SpectatorCamera' && players[consoleplayer].mo.health > 0)
	  {
	    PlayerPawn pmo = players[consoleplayer].mo;
		PlayerInfo cplr = players[consoleplayer];
	    float pang = pmo.angle;
	    float cyaw = isoyaw.GetFloat();
	    float cpit = isopitch.GetFloat();
	    float max_dist = isoaimdist.GetFloat();
		selstruct mypsel = MKeyEvents(EventHandler.Find("MKeyEvents")).psels[consoleplayer];

	    StatusBar.BeginHUD();
		Vector2 scaleFactor = StatusBar.GetHUDScale();

	    if(showwep.GetBool())
	    {
		  int wsize = (int)(clamp(wepsize.GetInt(), 1, 100));//*2/scaleFactor.x);
		  int wxpos = (int)(200*clamp(wepxpos.GetFloat(), -2.0, 2.0));//*scaleFactor.x);
		  int wypos = (int)(-200*clamp(wepypos.GetFloat(), 0.0, 2.0));//*scaleFactor.y);
		  let curwep = cplr.readyweapon;
		  let curpsp = cplr.FindPSprite(PSP_WEAPON);
		  if (curwep && curpsp && pmo.health > 0) // necessary check to prevent crash
		  {
			  StatusBar.DrawInventoryIcon(curwep, (wxpos, wypos),
										  StatusBar.DI_SCREEN_CENTER_BOTTOM | StatusBar.DI_ITEM_CENTER,
										  (curpsp.CurState == curwep.FindState("Fire") ) ||
										  curpsp.CurState.InStateSequence(curwep.FindState("Ready")) ? 1.0 : 0.7, // alpha
										  (2*wsize, wsize), (0.03*wsize, 0.03*wsize)); // boxsize, scale
			  if (showwepname.GetBool())
			  {
				  HUDFont monospaceSmallfont2 = HUDFont.Create(smallfont, smallfont.GetCharWidth("0"), true);
				  StatusBar.DrawString(monospaceSmallfont2, String.Format("%s", curwep.GetTag()),
									   (wxpos-(int)(0.8*wsize), wypos-(int)(0.8*wsize) + smallfont.GetCharWidth("0")),
									   StatusBar.DI_SCREEN_CENTER_BOTTOM | StatusBar.DI_ITEM_CENTER,
									   scale: (0.02*wsize, (hud_aspectscale ? 0.016 : 0.0134)*wsize));
			  }
		  }
	    }

		bool lup = lookingup.GetBool();
		bool ldown = lookingdown.GetBool();
	    int cursordist = ldown || lup ? pmo.viewheight : cursdist.GetInt(); // 150;
		int cursoroffy = cursoffy.GetInt();
	    float diffangle = pmo.deltaangle(pang, cyaw);
		float xscale = 0.375*( screenblocks >= 10 ? Screen.GetWidth() : 0.1*screenblocks*Screen.GetWidth() );
		float myfov = (cplr.camera.player ? cplr.camera.player.FOV : cplr.camera.CameraFOV);
		xscale *= 1.0 / tan (clamp(myfov, 5.0, 170.0) * 0.5);
		float yscale = 1.253229 - 0.0616458*sin(cpit)*sin(cpit) - 0.191609*sin(cpit);
		float aspratio = (1.0 * Screen.GetWidth()) / (1.0 * Screen.GetHeight());
		if (aspratio > 1.0) xscale *= 1.777778/aspratio;
		
	    int cosine = (int)(-0.5*cursordist*Cos(diffangle)*yscale) - cursoroffy;
	    int sine = (int)(cursordist*Sin(diffangle));
		int selcos = 0;
		int selsin = 0;
	    if(cplr.camera && cplr.camera.tracer)
	    {
	      if(cplr.camera.ViewPos && (cplr.camera.ViewPos.Flags & VPSF_ORTHOGRAPHIC))
	      { // If using orthographic projection
			  Vector3 playerdisp = cplr.camera.tracer.pos - cplr.camera.pos;
			  diffangle = pmo.deltaangle(playerdisp.Angle(), cyaw);
			  // Translate game/map (x, y, z) position into screen (x, y) location
			  double xproj = xscale/cplr.camera.ViewPos.offset.length();
			  double yproj = Sin(cpit)*xproj*yscale;
			  double zproj = Cos(cpit)*xproj*yscale;
			  cosine -= (int)(playerdisp.xy.length()*Cos(diffangle)*yproj); // + playerdisp.z*zproj); no need since Spectatorcamera tracks zpos
			  cosine -= (screenblocks <= 10 ? (int)(yscale*StatusBar.RelTop) : 0);
			  if (ldown) cosine += (int)(cplr.camera.tracer.height*0.25*zproj);
			  if (lup) cosine -= (int)(cplr.camera.tracer.height*0.25*zproj);
			  sine += (int)(playerdisp.xy.length()*Sin(diffangle)*xproj);
			  // else use libEye to locate camera.tracer's screen coordinates

			  // Do the same for position of selected object or switch
			  Vector3 seldisp = mypsel.selpos - cplr.camera.pos
				  - (0., 0., 0.5 * pmo.height * cplr.crouchfactor);
			  diffangle = pmo.deltaangle(seldisp.Angle(), cyaw);
			  selcos -= (int)(seldisp.xy.length()*Cos(diffangle)*yproj + seldisp.z*zproj);
			  selcos -= (screenblocks <= 10 ? (int)(yscale*StatusBar.RelTop) : 0);
			  selsin += (int)(seldisp.xy.length()*Sin(diffangle)*xproj);

			  if (mousemove.GetBool())
			  {
				  Inventory isomover = pmo.FindInventory("IsometricMovement");
				  /* if (isomover) console.printf("%d, %d\n", IsometricMovement(isomover).mousex, */
				  /* 							 IsometricMovement(isomover).mousey); */
				  oldmx += (int)(e.fracTic*(IsometricMovement(isomover).mousex - oldmx));
				  oldmy += (int)(e.fracTic*(IsometricMovement(isomover).mousey
											- (screenblocks <= 10 ? (int)(1.2*yscale*StatusBar.RelTop) : 0) - oldmy));
				  int cursortype = 0; // 0: aim_hair, 1: dir_hair, 2: sel_hair, 3: tar_hair
				  string cursorimg[4] = {"sprites/aim_hair.png", "sprites/dir_hair.png", "sprites/sel_hair.png", "sprites/tar_hair.png"};
				  if (IsometricMovement(isomover).pointusable && !IsometricMovement(isomover).pointshootable
					  && !IsometricMovement(isomover).fleemode && !IsometricMovement(isomover).hipfire)
					  cursortype = 2;
				  else if (IsometricMovement(isomover).fleemode) cursortype = 1;
				  else if (IsometricMovement(isomover).hipfire || IsometricMovement(isomover).pointshootable) cursortype = 3;
				  else cursortype = 0;
				  double cursorscale = (cursortype < 2 ? 1.2 : 0.75);
				  StatusBar.DrawImage(cursorimg[cursortype], (oldmx/scaleFactor.x, oldmy/scaleFactor.y),
									  StatusBar.DI_SCREEN_CENTER | StatusBar.DI_ITEM_CENTER,
									  scale: (cursorscale, cursorscale));
			  }
	      }
	    }

	    if (!mousemove.GetBool() && isoaimassist.GetBool() && !(ldown || lup))
	    {
	      StatusBar.DrawImage("sprites/aim_hair.png", (sine/scaleFactor.x, cosine/scaleFactor.y),
				  StatusBar.DI_SCREEN_CENTER | StatusBar.DI_ITEM_CENTER, scale: (1.2, 1.2));
	    } else if (!mousemove.GetBool()) {
	      StatusBar.DrawImage("sprites/dir_hair.png", (sine/scaleFactor.x, cosine/scaleFactor.y),
				  StatusBar.DI_SCREEN_CENTER | StatusBar.DI_ITEM_CENTER, scale: (0.75, 0.75));
	    }

		if (mypsel.isosel)
	    {
	      StatusBar.DrawImage("sprites/sel_hair.png", (selsin/scaleFactor.x, selcos/scaleFactor.y),
				  StatusBar.DI_SCREEN_CENTER | StatusBar.DI_ITEM_CENTER, scale: (0.75, 0.75));
	    }

	    if (actorhit[consoleplayer])
	    {
	      int cosine2 = 0;
	      int sine2 = 0;
	      if(cplr.camera && cplr.camera.ViewPos && (cplr.camera.ViewPos.Flags & VPSF_ORTHOGRAPHIC))
	      { // If using orthographic projection
			  Vector3 tardisp = actorhit[consoleplayer].pos
				  + (0., 0., (1.1*actorhit[consoleplayer].height - (cplr.camera.tracer ? cplr.camera.tracer.height : pmo.height)))
				  - cplr.camera.pos
				  + (0., 0., cplr.camera.pos.z - (cplr.camera.tracer ?
												  cplr.camera.tracer.pos.z : pmo.pos.z));
			  diffangle = pmo.deltaangle(tardisp.Angle(), cyaw);
			  // Translate game/map (x, y, z) position into screen (x, y) location
			  double xprj = xscale/cplr.camera.ViewPos.offset.length();
			  double yprj = Sin(cpit)*xprj*yscale;
			  double zprj = Cos(cpit)*xprj*yscale;
			  cosine2 -= (int)(tardisp.xy.length()*Cos(diffangle)*yprj);
			  cosine2 -= (int)(tardisp.z*zprj);
			  cosine2 -= (screenblocks > 10 ? 0 : (int)(yscale*StatusBar.RelTop));
			  sine2 += (int)(tardisp.xy.length()*Sin(diffangle)*xprj);
	      } // else use libEye to locate camera.tracer's screen coordinates
	      int halfw = (int)(Screen.GetWidth()/2);
	      int halfh = (int)(Screen.GetHeight()/2);
	      Screen.DrawLine(sine+halfw, cosine+halfh, sine2+halfw, cosine2+halfh, Color(aimbeam.GetString()));
	      StatusBar.DrawImage("sprites/tar_hair.png", (sine2/scaleFactor.x, cosine2/scaleFactor.y),
				  StatusBar.DI_SCREEN_CENTER | StatusBar.DI_ITEM_CENTER, scale: (1.5/scaleFactor.x, 1.5/scaleFactor.x));

		  float ssize = 0.02*clamp(scopesize.GetInt(), 1, 100);// /scaleFactor.x;
		  int sxpos = (int)(200*clamp(scopexpos.GetFloat(), -2.0, 2.0));//*scaleFactor.x);
		  int sypos = (int)(-200*clamp(scopeypos.GetFloat(), 0.0, 2.0));//*scaleFactor.y);

	      if(showscope.GetBool())
	      {
			  double tardist = (actorhit[consoleplayer].pos - cplr.camera.pos).length();
			  tardist -= (actorhit[consoleplayer].radius + pmo.radius);
			  double degree = 57.2957795 * actorhit[consoleplayer].height / (tardist > 0.0 ? tardist: 1.0); // in degrees
			  Actor myscopecam = CameraSpawnHandler(EventHandler.Find("CameraSpawnHandler")).scopecam[consoleplayer];
			  if (myscopecam)
			  {
				  if (!firstpersonscope.GetBool() && myscopecam.ViewPos)
					  degree = 0.00035*myscopecam.ViewPos.offset.length()*actorhit[consoleplayer].height;
				  texman.setcameratotexture(myscopecam, "CAMTEX_1", degree);
			  }

			  StatusBar.DrawImage("CAMTEX_1", (sxpos, sypos),
								  StatusBar.DI_SCREEN_CENTER_BOTTOM | StatusBar.DI_ITEM_CENTER,
								  scale: (ssize, ssize));
			  string scopesprite = (scopetype.GetInt() == 1 ? "sprites/scope_sight.png" : "sprites/scope_sight2.png");
			  if (scopetype.GetInt() == 3) scopesprite = "sprites/scope_sight3.png";
			  StatusBar.DrawImage(scopesprite, (sxpos, sypos),
								  StatusBar.DI_SCREEN_CENTER_BOTTOM | StatusBar.DI_ITEM_CENTER,
								  scale: (0.8*ssize, (hud_aspectscale ? 0.8 : 0.67)*ssize));
	      }

		  if (showscopehealth.GetBool())
		  {
			  string hpBar = makeHpBar(actorhit[consoleplayer].health,
									   getActorMaxHealth(actorhit[consoleplayer]));
			  HUDFont monospaceSmallfont = HUDFont.Create(smallfont, smallfont.GetCharWidth("0"), true);
			  StatusBar.DrawString(monospaceSmallfont, hpBar, (sxpos-(int)(30*ssize), sypos-(int)(40*ssize)),
								   StatusBar.DI_SCREEN_CENTER_BOTTOM | StatusBar.DI_ITEM_CENTER,
								   scale: (0.8*ssize, (hud_aspectscale ? 0.8 : 0.67)*ssize));
			  if (scopetargetname.GetBool())
			  {
				  StatusBar.DrawString(monospaceSmallfont, String.Format("%s", actorhit[consoleplayer].GetTag()),
									   (sxpos-(int)(30*ssize), sypos-(int)(40*ssize) + smallfont.GetCharWidth("0")),
									   StatusBar.DI_SCREEN_CENTER_BOTTOM | StatusBar.DI_ITEM_CENTER,
									   scale: (0.8*ssize, (hud_aspectscale ? 0.8 : 0.67)*ssize));
			  }
		  }
	    }
	  }
	}
}

class IsoAimAssistHandler : StaticEventHandler
{
	// copying Jay0's Aim Assist Mod v0.8
	// https://forum.zdoom.org/viewtopic.php?t=62895
	cvar aimassists[MAXPLAYERS]; // They say that GetCVar() inside WorldTick() is slow?
	cvar max_dists[MAXPLAYERS];
	cvar lookingup[MAXPLAYERS];
	cvar lookingdown[MAXPLAYERS];
	cvar mousemove[MAXPLAYERS];
	Inventory isomover[MAXPLAYERS];
	Actor scopecam[MAXPLAYERS];
	cvar firstpersonscope[MAXPLAYERS];

	override void WorldLoaded (WorldEvent e)
	{
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (PlayerInGame[i] && players[i].mo)
			{
				aimassists[i] = CVar.GetCVar("IsoAimAssist", players[i]);
				max_dists[i] = CVar.GetCVar("IsoAimAssistMaxDist", players[i]);
				lookingup[i] = CVar.GetCVar("IsoLookingUp", players[i]);
				lookingdown[i] = CVar.GetCVar("IsoLookingDown", players[i]);
				mousemove[i] = CVar.GetCVar("IsoMouseMove", players[i]);
				isomover[i] = players[i].mo.FindInventory("IsometricMovement");
				players[i].mo.bPickup = CVar.GetCVar("IsoAllowTouchPickup", players[i]).GetBool(); // Didn't want another staticeventhandler
				MKeyEvents(EventHandler.Find("MKeyEvents")).psels[i].isosel = false; // Didn't want another staticeventhandler
				scopecam[i] = CameraSpawnHandler(EventHandler.Find("CameraSpawnHandler")).scopecam[i];
				firstpersonscope[i] = Cvar.GetCvar("IsoHUDScopeFirstPerson", players[i]);
			}
		}
	}

	// do linetrace and get results
	play Actor,double,Vector3 doTrace(PlayerPawn a,double i_angle,double i_rotation,Actor closest,double closest_distance, double max_dist){
		FLineTraceData t;
		Vector3 hitloc=(0,0,0);
		//do a linetrace around i_a and i_r in a circle
		if(a.LineTrace(a.angle+(sin(i_rotation)*i_angle),			//trace angle
							max_dist,							//trace max distance
							a.pitch+(cos(i_rotation)*i_angle*8),		//trace pitch (modified by factor 8)
							TRF_NOSKY,								//trace flags
							a.viewheight*a.player.crouchfactor,		//trace height
							data:t									//output struct
		)){
			if(t.hitType==TRACE_HitActor){//if hit is an actor
				
				if(t.hitActor.bISMONSTER&&!t.hitActor.bFRIENDLY&&!t.hitActor.bCORPSE){//if hit is a monster and not friendly
					if(!closest||a.Distance3D(t.HitActor)>closest_distance){//if it's closer than last hit
						//change this as new closest
						closest=t.HitActor;
						closest_distance=a.Distance3D(t.HitActor);
						hitloc=t.HitLocation;
					}
				}
			}
		}
		return closest,closest_distance,hitloc;
	}

	//get angle and delta from two positions
	static vector3, double, double lookAt(Vector3 pos1, Vector3 pos2){
		//calculate difference between pos1 and pos2 (level.Vec3Diff takes portals into account)
		
		Vector3 delta=level.Vec3Diff(pos1, pos2);
		
		//calculate angle and pitch to other actor
		double target_angle = atan2(delta.y, delta.x);
		double target_pitch = -asin(delta.z/delta.length());

		return delta, target_angle, target_pitch;
	}

	//main method, does all work
	bool doAim(int pnum)
	{
		PlayerPawn pawn = players[pnum].mo;
		Actor closest = null;
		Actor hit = null;
		Vector3 hitloc = (0, 0, 0);
		cvar aimassist = aimassists[pnum];
		float max_dist = max_dists[pnum].GetFloat();
		float closest_distance = max_dist + 1;
		
		//check straight ahead
		[closest, closest_distance, hitloc] = doTrace(pawn, 0, 0, closest, closest_distance, max_dist);

		// Convert these to CVars?
		double precision = 0.5;
		double radial_precision = 8;
		double max_angle = 8;

		//check in a circle around the direction player's looking
		for(double i_a = 0; i_a <= max_angle; i_a += precision) {
			for(double i_r = 0; i_r <= 360 && !closest; i_r += radial_precision) {
				[closest, closest_distance, hitloc] = doTrace(pawn, i_a, i_r, closest, closest_distance, max_dist);
			}
		}

		//if there was an enemy found
		if(closest){
		  float pheight = pawn.viewheight*pawn.player.crouchfactor;
		  Vector3 aimheight=(0, 0, closest.height);
		  Vector3 delta;
		  double target_angle,target_pitch;
		  Vector3 view=pawn.pos + (0, 0, pheight);
		  //get target angle and pitch
		  [delta, target_angle, target_pitch] = lookAt(view, closest.pos + aimheight);
			
		  //check if view is obstructed
		  FLineTraceData t;
		  pawn.LineTrace(target_angle, max_dist, target_pitch,
				 TRF_NOSKY, pawn.viewheight*pawn.player.crouchfactor, data:t);
		  //aim correction
		  if((t.hitType != TRACE_HitActor) || (t.hitActor != closest)){
		    //try to aim at correct z
		    [delta, target_angle, target_pitch] = lookAt(view, (hitloc.x, hitloc.y, closest.pos.z + aimheight.z));
		    pawn.LineTrace(target_angle, max_dist, target_pitch, TRF_NOSKY, pawn.viewheight * pawn.player.crouchfactor, data:t);
		  }
		  if((t.hitType != TRACE_HitActor) || (t.hitActor != closest)){
		    //try to aim at correct xy
		    [delta, target_angle, target_pitch] = lookAt(view, (closest.pos.x, closest.pos.y, hitloc.z));
		    pawn.LineTrace(target_angle, max_dist, target_pitch, TRF_NOSKY, pawn.viewheight * pawn.player.crouchfactor, data:t);
		  }
		  /* if((t.hitType != TRACE_HitActor) || (t.hitActor != closest)){ */
		  /*   // target closest */
		  /*   [delta, target_angle, target_pitch] = lookAt(view, hitloc); */
		  /* } */
		  if((t.hitType != TRACE_HitActor) || (t.hitActor != closest)){
		    // Stop aiming
		    return false;
		  }

		  //get angle difference
		  double angle_diff = pawn.DeltaAngle(pawn.angle, target_angle);
		  double pitch_diff = pawn.DeltaAngle(pawn.pitch, target_pitch);

		  double rot_speed = (mousemove[pnum].GetBool() ? 10.0 : 1.0);
		  if (aimassist.GetBool())
		  {
		    //check rotation speed
		    if(abs(angle_diff) > rot_speed){
		      //if rotation speed is lower than difference, add/subtract rotation speed
		      pawn.A_SetAngle(pawn.angle + (angle_diff > 0 ? rot_speed : -rot_speed), SPF_INTERPOLATE);
		    } else {
		      //if rotation speed is higher than differece, set to target angle
		      pawn.A_SetAngle(target_angle, SPF_INTERPOLATE);
		    }
			if (scopecam[pnum] && !firstpersonscope[pnum].GetBool())
			{
				if (scopecam[pnum].tracer != t.hitActor && scopecam[pnum].ViewPos)
				{
					float newZ = scopecam[pnum].ViewPos.offset.length() * Sin(scopecam[pnum].pitch)
						+ 0.5 * t.hitActor.height;
					scopecam[pnum].SetViewPos((scopecam[pnum].ViewPos.offset.X, scopecam[pnum].ViewPos.offset.Y, newZ), -1);
					scopecam[pnum].CameraFOV = 0.00035 * scopecam[pnum].ViewPos.offset.length()
						* (t.hitActor.height > 2.0 * t.hitActor.radius ? t.hitActor.height : 2.0 * t.hitActor.radius);
				}
				scopecam[pnum].tracer = t.hitActor;
			}
		  }
		  
		  if(abs(pitch_diff) > rot_speed){
		    //if rotation speed is lower than difference, add/subtract rotation speed
		    pawn.A_SetPitch(pawn.pitch + (pitch_diff > 0 ? rot_speed : -rot_speed), SPF_INTERPOLATE);
		  } else {
		    //if rotation speed is higher than differece, set to target pitch
		    pawn.A_SetPitch(target_pitch, SPF_INTERPOLATE);
		  }
		  return true;
		} else {
		  return false;
		}
	}

	override void WorldTick()
	{
	  for (int i = 0; i < MAXPLAYERS; i++)
	  {
	    if (PlayerInGame[i] && players[i].mo)
	    {
			if (lookingup[i].GetBool()) players[i].mo.A_SetPitch(-45);
			else if (lookingdown[i].GetBool()) players[i].mo.A_SetPitch(45);
			else
			{
				if (mousemove[i].GetBool() && isomover[i])
				{
					if (!IsometricMovement(isomover[i]).fleemode && !doAim(i))
					{
						players[i].mo.A_SetPitch((IsometricMovement(isomover[i]).plrpitch > 5 ? // Avoid hipfire to ground
												  0 : IsometricMovement(isomover[i]).plrpitch));
					}
				}
				else if (!doAim(i)) players[i].mo.A_SetPitch(0);
			}
	    }
	  }
	}

}

// Taken from a demo meant for the D4D team.
// I can't track down who to credit here.
// Is it MajorCooke?
// Slightly modified to take camera angle into account.
Class D4DHandler2 : EventHandler
{
	override void OnRegister()
	{
		SetOrder(666);
		Super.OnRegister();
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		ArrowManager = D4VisualDamageManager2.Create();
	}
	
	override void RenderOverlay(RenderEvent e)
	{
		RenderDamageIndicators(e);
	}
	
	override void WorldTick()
	{
		TickDamageIndicators();
	}
	
	override void WorldThingDamaged(WorldEvent e)
	{
		Actor damaged =	e.Thing;
		
		if (damaged.player)
		{
			Actor	src = e.DamageSource,
					inf = e.Inflictor;
			
			if (!src && !inf)
				return;
			
			AddEventDamageIndicator(e);
		}
	
	}
	
	
	
	private D4VisualDamageManager2 ArrowManager;
	private ui void RenderDamageIndicators(RenderEvent e)
	{
		if (ArrowManager)
			ArrowManager.Render(e);
	}
	
	private void TickDamageIndicators()
	{
		if (ArrowManager)
			ArrowManager.Tick();
	}
	
	private void AddEventDamageIndicator(WorldEvent e)
	{
		if (ArrowManager)
			ArrowManager.AddIndicator(e.DamageSource, e.Inflictor, e.Thing, e.Damage);
	}
	
	void AddDamageIndicator(Actor src, Actor inf, Actor plr, int damage)
	{
		if (ArrowManager)
		{
			ArrowManager.AddIndicator(src, inf, plr, damage);
		}
	}
}

//==============================================================================
// Damage Indicators
//==============================================================================

Class D4VisualDamageManager2 play
{
	private Array<D4DamageIndicator2> Arrows;
	private int Timer;
	const ClearTimer = 5 * 5;
	
	static D4VisualDamageManager2 Create()
	{
		let vdm = new('D4VisualDamageManager2');
		vdm.Init();
		return vdm;
	}
	
	protected void Init()
	{
		Arrows.Clear();
	}
	
	void AddIndicator(Actor src, Actor inf, Actor plr, int damage = 0)
	{
		if ((!src && !inf) || !plr || src == plr)
			return;
		
		for (int i = 0; i < Arrows.Size(); i++)
		{
			if (Arrows[i] && Arrows[i].src == src)
			{
				Arrows[i].ResetTimer();
			//	Console.Printf("Updated arrow.");
				return;
			}
		}
		
		let arrow = new('D4DamageIndicator2');
		arrow.src = src;
		arrow.inf = inf;
		if (src)	arrow.srcpos = src.pos;
		else if ((inf && inf.bMISSILE && inf.target) || inf)
		{
			src = (inf.target) ? inf.target : inf;
			arrow.srcpos = src.pos;
		}
		if (inf)	arrow.infpos = inf.pos;
		arrow.plr = plr;
		arrow.tex = TexMan.CheckForTexture(D4DamageIndicator2.texname,TexMan.Type_Any);
		arrow.ResetTimer();
		arrow.Init();
		Arrows.Push(arrow);
	}
	
	void Tick()
	{
		int size = Arrows.Size();
		if (size < 1)	return;
		
		// Tick all the arrows and keep their information up to date.
		for (int i = 0; i < size; i++)
		{
			if (Arrows[i])
				Arrows[i].Tick();
		}
		
		// Memory management. Remove all empty slots.
		if (++Timer >= ClearTimer)
		{
			Timer = 0;
			Array<D4DamageIndicator2> temp; temp.Clear();
			
			for (int i = 0; i < size; i++)
				if (Arrows[i])	temp.Push(Arrows[i]);
			
			Arrows.Move(temp);
		}
	}
	
	ui void Render(RenderEvent e)
	{
		if (Arrows.Size() < 1)
			return;
		
		PlayerInfo plr = players[consoleplayer];
		let CDIAlpha = Cvar.GetCvar('D4D2_DIAlpha', plr);
		let CDIScale = Cvar.GetCvar('D4D2_DIScale', plr);
		double Alpha = 1.0, Scale = 0.5;
		
		if (CDIAlpha)	Alpha = CDIAlpha.GetFloat();
		if (CDIScale)	Scale = CDIScale.GetFloat();
		
		int size = Arrows.Size();
		for (int i = 0; i < size; i++)
		{
			let arrow = D4DamageIndicator2(Arrows[i]);
			if (arrow && arrow.pinfo == plr)
				Arrows[i].Render(e, Alpha, Scale);
		}
	}
}

Class D4DamageIndicator2 play
{
	const texname = "sprites/DmgDir2.png";
	Actor inf, src, plr;
	PlayerInfo pinfo;
	Vector3 infpos, srcpos;
	TextureID tex;
	private double Alpha, Scale;
	private int Timer;
	
	private bool hadsrc, hadinf;
	private Vector2 siz;
	private Shape2D flat;
	private Shape2DTransform trans;
	
	void Init()
	{
		hadsrc = src != null;
		hadinf = inf != null;
		pinfo = plr.player;
		flat = new("Shape2D");
		
		// simple coords
		flat.PushCoord((0,0));	// 0
		flat.PushCoord((1,0));	// 1
		flat.PushCoord((0,1));	// 2
		flat.PushCoord((1,1));	// 3
		
		// PushTriangle takes INDEXES of coords pushed to it in order from
		// first to last, as numbered above.
		flat.PushTriangle(0,2,1); // (0,0) (0,1) (1,0)
		flat.PushTriangle(2,3,1); // (0,1) (1,1) (1,0)
		siz = TexMan.GetScaledSize(tex);
		
		// Create the vertices and push them into the array.
		Vector2 vertices[4];
		vertices[0] = (-siz.x,-siz.y);
		vertices[1] = ( siz.x,-siz.y);
		vertices[2] = (-siz.x, siz.y);
		vertices[3] = ( siz.x, siz.y);
		
		flat.Clear(Shape2D.C_Verts);
		for ( int i=0; i<4; i++ ) flat.PushVertex(vertices[i]);
		
		trans = new('Shape2DTransform');
	}
	
	void ResetTimer(int time = -1)
	{
		if (time < 1)	time = (5 * 5);
		Timer = time;
	}
	
	void Tick()
	{
		if (--Timer < 0 || !plr)
		{
		//	Console.Printf("Destroyed");
			Destroy();	return;	
		}
		
		if (!src && inf && inf.bMISSILE)
			src = inf.target;
		
		if (src)	srcpos = src.pos;
		if (inf)	infpos = inf.pos;
		
	}
	const ThirtyFifth = (1.0 / 35.0);
	ui void Render( RenderEvent e, double _Alpha, double _Scale)
	{	
		// Alpha is already clamped below.
		double Alpha = (ThirtyFifth * Timer) * _Alpha;
		double Scale = _Scale;
		
		if (bDESTROYED || Alpha <= 0.0 || !plr || plr.pos == srcpos || !hadsrc)
			return;
		
		// Grab the player preferences.
		trans.Clear();
		
		// Rotate the damage indicator towards the one responsible.
		Vector3 diff = level.Vec3Diff(srcpos, plr.pos);
		double ang = VectorAngle(diff.X, diff.Y);
		if (pinfo.camera) ang = -plr.DeltaAngle(pinfo.camera.angle, ang);
		else ang = -plr.DeltaAngle(plr.angle, ang);

		Vector2 s = (Screen.GetWidth() / 2, Screen.GetHeight() / 2);
		
		double off = (siz.y + (siz.y * Scale)) * 0.75;
		Vector2 add = (-sin(ang) * off, cos(ang) * off);
		s += add;
		
		trans.Scale((1, 1) * Scale);
		trans.Rotate(ang + 180.0);
		trans.Translate(s);
		
		flat.SetTransform(trans);
		
			
		// draw the shape
		Screen.DrawShape(tex,false,flat,DTA_Alpha, Clamp(Alpha, 0.0, 1.0));
		
	}
}
